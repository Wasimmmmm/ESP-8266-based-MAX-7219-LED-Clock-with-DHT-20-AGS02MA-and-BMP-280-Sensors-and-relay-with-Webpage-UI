package com.example.nativeSmartHome

import android.os.Bundle
import android.util.Log
import android.widget.*
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.google.android.material.materialswitch.MaterialSwitch
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import org.json.JSONException
import org.json.JSONObject
import java.io.IOException
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType

class MainActivity : AppCompatActivity() {

    // Network related
    private lateinit var client: OkHttpClient
    private var deviceIP = "192.168.0.108"
    private lateinit var baseUrl: String

    // Loading screen elements
    private lateinit var loadingContainer: LinearLayout
    private lateinit var loadingProgressBar: ProgressBar
    private lateinit var loadingPercentage: TextView
    private lateinit var loadingText: TextView
    private lateinit var mainContent: ScrollView
    private var loadingStartTime: Long = 0

    // Loading state tracking
    private var completedTasks = 0
    private val totalTasks = 6
    private var allTasksCompleted = false
    private var smoothLoadingJob: Job? = null

    // UI Elements - Sensor data
    private lateinit var tvIpAddress: TextView
    private lateinit var tvTemperature: TextView
    private lateinit var tvHumidity: TextView
    private lateinit var tvHeatIndex: TextView
    private lateinit var tvPressure: TextView
    private lateinit var tvTvoc: TextView
    private lateinit var tvBrightnessValue: TextView

    // UI Elements - Status
    private lateinit var tvFanStatus: TextView
    private lateinit var tvBigLightStatus: TextView
    private lateinit var tvLightStatus: TextView
    private lateinit var tvTimerStatus: TextView
    private lateinit var tvClockBrightnessValue: TextView

    // UI Elements - Switches
    private lateinit var switchFan: MaterialSwitch
    private lateinit var switchBigLight: MaterialSwitch
    private lateinit var switchLight: MaterialSwitch
    private lateinit var switchVocAuto: MaterialSwitch
    private lateinit var switchClockRelay: MaterialSwitch
    private lateinit var switchAutoBrightness: MaterialSwitch
    private lateinit var switchClockAutoBrightness: MaterialSwitch

    // UI Elements - Timer controls
    private lateinit var spinnerTimerDevice: Spinner
    private lateinit var spinnerTimerState: Spinner
    private lateinit var etTimerDuration: EditText
    private lateinit var btnStartTimer: Button
    private lateinit var btnCancelTimer: Button
    private lateinit var btnRestartDevice: Button

    // UI Elements - Settings
    private lateinit var seekbarBrightness: SeekBar
    private lateinit var seekbarClockBrightness: SeekBar

    // Coroutine jobs for managing async operations
    private var sensorRefreshJob: Job? = null
    private var deviceStateRefreshJob: Job? = null
    private var timerRefreshJob: Job? = null
    private var brightnessUpdateJob: Job? = null
    private var clockBrightnessUpdateJob: Job? = null

    // Debounce delays - shorter for more responsive UI
    private val seekbarDebounceDelay = 150L
    private val switchMutex = Mutex()

    // Separate scopes for different update frequencies
    private val fastUpdateScope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    private val slowUpdateScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        initializeNetwork()
        initializeViews()
        setupEventListeners()
        setupSpinners()
        loadDeviceIP()

        showLoadingScreen()
        loadInitialDataAsync()
    }

    override fun onResume() {
        super.onResume()
        if (loadingContainer.visibility != android.view.View.VISIBLE) {
            showLoadingScreen()
            loadInitialDataAsync()
        } else {
            startDataRefreshAsync()
        }
    }

    override fun onPause() {
        super.onPause()
        stopAllJobs()
    }

    override fun onDestroy() {
        super.onDestroy()
        stopAllJobs()
        fastUpdateScope.cancel()
        slowUpdateScope.cancel()
    }

    private fun stopAllJobs() {
        sensorRefreshJob?.cancel()
        deviceStateRefreshJob?.cancel()
        timerRefreshJob?.cancel()
        smoothLoadingJob?.cancel()
        brightnessUpdateJob?.cancel()
        clockBrightnessUpdateJob?.cancel()
    }

    private fun initializeNetwork() {
        client = OkHttpClient.Builder()
            .connectTimeout(2, java.util.concurrent.TimeUnit.SECONDS)
            .readTimeout(3, java.util.concurrent.TimeUnit.SECONDS)
            .writeTimeout(3, java.util.concurrent.TimeUnit.SECONDS)
            .build()
        updateBaseUrl()
    }

    private fun updateBaseUrl() {
        baseUrl = "http://$deviceIP"
    }

    private fun loadDeviceIP() {
        val prefs = getSharedPreferences("JARVIS_PREFS", MODE_PRIVATE)
        deviceIP = prefs.getString("device_ip", deviceIP) ?: deviceIP
        updateBaseUrl()
    }

    private fun initializeViews() {
        // Loading screen elements
        loadingContainer = findViewById(R.id.loading_container)
        loadingProgressBar = findViewById(R.id.loading_progress_bar)
        loadingPercentage = findViewById(R.id.loading_percentage)
        loadingText = findViewById(R.id.loading_text)
        mainContent = findViewById(R.id.main_content)

        // Sensor data TextViews
        tvIpAddress = findViewById(R.id.tv_ip_address)
        tvTemperature = findViewById(R.id.tv_temperature)
        tvHumidity = findViewById(R.id.tv_humidity)
        tvHeatIndex = findViewById(R.id.tv_heat_index)
        tvPressure = findViewById(R.id.tv_pressure)
        tvTvoc = findViewById(R.id.tv_tvoc)
        tvBrightnessValue = findViewById(R.id.tv_brightness_value)

        // Status TextViews
        tvFanStatus = findViewById(R.id.tv_fan_status)
        tvBigLightStatus = findViewById(R.id.tv_big_light_status)
        tvLightStatus = findViewById(R.id.tv_light_status)
        tvTimerStatus = findViewById(R.id.tv_timer_status)
        tvClockBrightnessValue = findViewById(R.id.tv_clock_brightness_value)

        // Switches
        switchFan = findViewById(R.id.switch_fan)
        switchBigLight = findViewById(R.id.switch_big_light)
        switchLight = findViewById(R.id.switch_light)
        switchVocAuto = findViewById(R.id.switch_voc_auto)
        switchClockRelay = findViewById(R.id.switch_clock_relay)
        switchAutoBrightness = findViewById(R.id.switch_auto_brightness)
        switchClockAutoBrightness = findViewById(R.id.switch_clock_auto_brightness)

        // Initial states
        switchFan.isChecked = true
        switchBigLight.isChecked = true
        switchLight.isChecked = true
        switchVocAuto.isChecked = true
        switchClockRelay.isChecked = true
        switchAutoBrightness.isChecked = true
        switchClockAutoBrightness.isChecked = true

        // Timer controls
        spinnerTimerDevice = findViewById(R.id.spinner_timer_device)
        spinnerTimerState = findViewById(R.id.spinner_timer_state)
        etTimerDuration = findViewById(R.id.et_timer_duration)
        btnStartTimer = findViewById(R.id.btn_start_timer)
        btnCancelTimer = findViewById(R.id.btn_cancel_timer)

        // Settings
        seekbarBrightness = findViewById(R.id.seekbar_brightness)
        seekbarClockBrightness = findViewById(R.id.seekbar_clock_brightness)
        btnRestartDevice = findViewById(R.id.btn_restart_device)
    }

    private fun showLoadingScreen() {
        loadingContainer.visibility = android.view.View.VISIBLE
        mainContent.visibility = android.view.View.INVISIBLE

        completedTasks = 0
        allTasksCompleted = false
        loadingStartTime = System.currentTimeMillis()

        startSmoothLoading()
    }

    private fun startSmoothLoading() {
        val loadingMessages = arrayOf(
            "Connecting to JARVIS...",
            "Loading sensors...",
            "Getting device states...",
            "Syncing data..."
        )

        smoothLoadingJob = lifecycleScope.launch {
            var waitingMessageShown = false

            while (isActive) {
                val elapsed = System.currentTimeMillis() - loadingStartTime
                val progress = when {
                    elapsed < 1500 -> (elapsed * 80 / 1500).toInt()
                    allTasksCompleted -> {
                        val completionElapsed = elapsed - 1500
                        minOf(80 + (completionElapsed * 20 / 800).toInt(), 100)
                    }
                    else -> 80
                }

                loadingProgressBar.progress = progress
                loadingPercentage.text = "$progress%"

                if (progress < 80) {
                    val messageIndex = minOf(progress / 20, loadingMessages.size - 1)
                    loadingText.text = loadingMessages[messageIndex]
                } else {
                    if (allTasksCompleted) {
                        loadingText.text = "Ready!"
                    } else if (elapsed > 5000 && !waitingMessageShown) {
                        loadingText.text = "Waiting for connection..."
                        retryLoadingInitialData()
                        waitingMessageShown = true
                    } else if (!waitingMessageShown) {
                        loadingText.text = "Finalizing..."
                    }
                }

                if (progress == 100 && allTasksCompleted) {
                    delay(300)
                    hideLoadingScreen()
                    break
                }

                delay(100)
            }
        }
    }

    private fun retryLoadingInitialData() {
        fastUpdateScope.launch {
            delay(3000) // retry delay
            if (!allTasksCompleted && loadingContainer.visibility == android.view.View.VISIBLE) {
                loadInitialDataAsync()
            }
        }
    }



    private fun onLoadingTaskComplete() {
        completedTasks++
        if (completedTasks >= totalTasks) {
            allTasksCompleted = true
        }
    }

    private fun hideLoadingScreen() {
        smoothLoadingJob?.cancel()
        loadingContainer.visibility = android.view.View.GONE
        mainContent.visibility = android.view.View.VISIBLE
        startDataRefreshAsync()
    }

    private fun setupEventListeners() {
        // Ultra-fast switch responses with immediate UI feedback
        switchFan.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                tvFanStatus.text = if (isChecked) "On" else "Off"

                fastUpdateScope.launch {
                    switchMutex.withLock {
                        val success = toggleDeviceAsync("fan")
                        if (!success) {
                            withContext(Dispatchers.Main) {
                                switchFan.isChecked = !isChecked
                                tvFanStatus.text = if (!isChecked) "On" else "Off"
                                showError("Failed to toggle fan")
                            }
                        }
                        delay(100)
                        fetchDeviceStatesAsync()
                    }
                }
            }
        }

        switchBigLight.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                tvBigLightStatus.text = if (isChecked) "On" else "Off"

                fastUpdateScope.launch {
                    switchMutex.withLock {
                        val success = toggleDeviceAsync("bigLight")
                        if (!success) {
                            withContext(Dispatchers.Main) {
                                switchBigLight.isChecked = !isChecked
                                tvBigLightStatus.text = if (!isChecked) "On" else "Off"
                                showError("Failed to toggle big light")
                            }
                        }
                        delay(100)
                        fetchDeviceStatesAsync()
                    }
                }
            }
        }

        switchLight.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                tvLightStatus.text = if (isChecked) "On" else "Off"

                fastUpdateScope.launch {
                    switchMutex.withLock {
                        val success = toggleDeviceAsync("light")
                        if (!success) {
                            withContext(Dispatchers.Main) {
                                switchLight.isChecked = !isChecked
                                tvLightStatus.text = if (!isChecked) "On" else "Off"
                                showError("Failed to toggle light")
                            }
                        }
                        delay(100)
                        fetchDeviceStatesAsync()
                    }
                }
            }
        }

        // Fast response switches
        switchVocAuto.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                fastUpdateScope.launch { toggleVOCControlAsync(isChecked) }
            }
        }

        switchClockRelay.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                fastUpdateScope.launch { toggleClockRelayAsync(isChecked) }
            }
        }

        switchAutoBrightness.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                seekbarBrightness.isEnabled = !isChecked
                fastUpdateScope.launch { toggleAutoBrightnessAsync(isChecked) }
            }
        }

        switchClockAutoBrightness.setOnCheckedChangeListener { buttonView, isChecked ->
            if (buttonView.isPressed) {
                seekbarClockBrightness.isEnabled = !isChecked
                fastUpdateScope.launch { toggleClockAutoBrightnessAsync(isChecked) }
            }
        }

        // Faster brightness controls
        seekbarBrightness.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                if (fromUser) {
                    tvBrightnessValue.text = "$progress%"
                }
            }

            override fun onStartTrackingTouch(seekBar: SeekBar?) {}

            override fun onStopTrackingTouch(seekBar: SeekBar?) {
                seekBar?.let {
                    brightnessUpdateJob?.cancel()
                    brightnessUpdateJob = fastUpdateScope.launch {
                        delay(seekbarDebounceDelay)
                        setBrightnessAsync(it.progress)
                    }
                }
            }
        })

        seekbarClockBrightness.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                if (fromUser) {
                    tvClockBrightnessValue.text = progress.toString()
                }
            }

            override fun onStartTrackingTouch(seekBar: SeekBar?) {}

            override fun onStopTrackingTouch(seekBar: SeekBar?) {
                seekBar?.let {
                    clockBrightnessUpdateJob?.cancel()
                    clockBrightnessUpdateJob = fastUpdateScope.launch {
                        delay(seekbarDebounceDelay)
                        setClockBrightnessAsync(it.progress)
                    }
                }
            }
        })

        // Fast button responses
        btnStartTimer.setOnClickListener {
            fastUpdateScope.launch { startTimerAsync() }
        }
        btnCancelTimer.setOnClickListener {
            fastUpdateScope.launch { cancelAllTimersAsync() }
        }
        btnRestartDevice.setOnClickListener { restartDevice() }
    }

    private fun setupSpinners() {
        val deviceAdapter = ArrayAdapter.createFromResource(
            this,
            R.array.timer_devices,
            android.R.layout.simple_spinner_item
        )
        deviceAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        spinnerTimerDevice.adapter = deviceAdapter

        updateTimerStateSpinner("Fan")

        spinnerTimerDevice.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: android.view.View?, position: Int, id: Long) {
                val selectedDevice = parent?.getItemAtPosition(position).toString()
                updateTimerStateSpinner(selectedDevice)
            }

            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
    }

    private fun updateTimerStateSpinner(device: String) {
        val stateAdapter = if (device == "Fan") {
            ArrayAdapter.createFromResource(this, R.array.fan_states, android.R.layout.simple_spinner_item)
        } else {
            ArrayAdapter.createFromResource(this, R.array.light_states, android.R.layout.simple_spinner_item)
        }
        stateAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        spinnerTimerState.adapter = stateAdapter
    }

    private fun loadInitialDataAsync() {
        tvIpAddress.text = "IP: $deviceIP"
        tvTemperature.text = "--°C"
        tvHumidity.text = "--%"
        tvHeatIndex.text = "--°C"
        tvPressure.text = "--mmHg"
        tvTvoc.text = "--ppb"
        tvBrightnessValue.text = "--%"

        tvFanStatus.text = "--"
        tvBigLightStatus.text = "--"
        tvLightStatus.text = "--"
        tvTimerStatus.text = "No active timers"

        // Parallel async loading for speed
        fastUpdateScope.launch {
            listOf(
                async { fetchSensorDataAsync() },
                async { fetchDeviceStatesAsync() },
                async { fetchTimerStatusAsync() },
                async { fetchVOCControlStateAsync() },
                async { fetchClockRelayStateAsync() },
                async { fetchClockBrightnessStateAsync() }
            ).awaitAll()
        }
    }

    private fun startDataRefreshAsync() {
        // Sensor data refresh - 2 second interval
        sensorRefreshJob = slowUpdateScope.launch {
            while (isActive) {
                fetchSensorDataAsync()
                delay(2000)
            }
        }

        // Device states refresh - 100ms for faster UI updates
        deviceStateRefreshJob = fastUpdateScope.launch {
            while (isActive) {
                fetchDeviceStatesAsync()
                delay(100)
            }
        }

        // Timer status refresh - 10 seconds (less critical)
        timerRefreshJob = slowUpdateScope.launch {
            while (isActive) {
                async { fetchTimerStatusAsync() }
                async { fetchVOCControlStateAsync() }
                async { fetchClockRelayStateAsync() }
                async { fetchClockBrightnessStateAsync() }
                delay(10000)
            }
        }
    }

    // Optimized async network methods
    private suspend fun makeGetRequestAsync(endpoint: String): Result<String> = withContext(Dispatchers.IO) {
        try {
            val request = Request.Builder()
                .url(baseUrl + endpoint)
                .build()

            val response = client.newCall(request).execute()
            val responseBody = response.body?.string() ?: ""

            if (response.isSuccessful) {
                Result.success(responseBody)
            } else {
                Result.failure(Exception("HTTP ${response.code}"))
            }
        } catch (e: IOException) {
            Result.failure(e)
        }
    }

    private suspend fun makePostRequestAsync(endpoint: String, postData: String): Result<String> = withContext(Dispatchers.IO) {
        try {
            val body = RequestBody.create(
                "application/x-www-form-urlencoded".toMediaType(),
                postData
            )

            val request = Request.Builder()
                .url(baseUrl + endpoint)
                .post(body)
                .build()

            val response = client.newCall(request).execute()
            val responseBody = response.body?.string() ?: ""

            if (response.isSuccessful) {
                Result.success(responseBody)
            } else {
                Result.failure(Exception("HTTP ${response.code}"))
            }
        } catch (e: IOException) {
            Result.failure(e)
        }
    }

    // Fast async data fetching methods
    // Modified fetchSensorDataAsync
    private suspend fun fetchSensorDataAsync() = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/sensorData")
        result.onSuccess { response ->
            try {
                val json = JSONObject(response)
                tvTemperature.text = String.format("%.1f°C", json.getDouble("avgTemp"))
                tvHumidity.text = String.format("%.1f%%", json.getDouble("avgHumid"))
                tvHeatIndex.text = String.format("%.1f°C", json.getDouble("heatIndex"))
                tvPressure.text = String.format("%.1fmmHg", json.getDouble("pressure"))
                tvTvoc.text = "${json.getInt("tvoc")}ppb"

                val brightness = json.getInt("brightness")
                tvBrightnessValue.text = "$brightness%"
                if (!switchAutoBrightness.isPressed) seekbarBrightness.progress = brightness

                val autoBrightness = json.getBoolean("autoBrightness")
                if (!switchAutoBrightness.isPressed) {
                    switchAutoBrightness.isChecked = autoBrightness
                    seekbarBrightness.isEnabled = !autoBrightness
                }
                Log.d("MainActivity", "Sensor data valid")
                if (loadingContainer.visibility == android.view.View.VISIBLE) onLoadingTaskComplete()
            } catch (e: JSONException) {
                Log.e("MainActivity", "Sensor data parse error", e)
            }
        }
    }

    // Modified fetchDeviceStatesAsync
    private suspend fun fetchDeviceStatesAsync() = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/deviceStates")
        result.onSuccess { response ->
            try {
                val json = JSONObject(response)

                if (!switchFan.isPressed) {
                    val fanState = json.getString("fan")
                    tvFanStatus.text = fanState
                    switchFan.isChecked = !fanState.contains("Off")
                }

                if (!switchBigLight.isPressed) {
                    val bigLightState = json.getString("bigLight")
                    tvBigLightStatus.text = bigLightState
                    switchBigLight.isChecked = bigLightState == "On"
                }

                if (!switchLight.isPressed) {
                    val lightState = json.getString("light")
                    tvLightStatus.text = lightState
                    switchLight.isChecked = lightState == "On"
                }
                Log.d("MainActivity", "Device states valid")
                if (loadingContainer.visibility == android.view.View.VISIBLE) onLoadingTaskComplete()
            } catch (e: JSONException) {
                Log.e("MainActivity", "Device states parse error", e)
            }
        }
    }

    // Modified fetchTimerStatusAsync
    private suspend fun fetchTimerStatusAsync() = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/timer/status")
        result.onSuccess { response ->
            try {
                val json = JSONObject(response)
                val hasActiveTimers = json.getBoolean("hasActiveTimers")

                if (!hasActiveTimers) {
                    tvTimerStatus.text = "No active timers"
                } else {
                    val timers = json.getJSONArray("timers")
                    val status = StringBuilder()
                    for (i in 0 until timers.length()) {
                        val timer = timers.getJSONObject(i)
                        if (i > 0) status.append("\n")
                        status.append(timer.getString("device"))
                            .append(" → ")
                            .append(timer.getString("targetState"))
                            .append(" in ")
                            .append(timer.getString("remainingTime"))
                    }
                    tvTimerStatus.text = status.toString()
                }
                Log.d("MainActivity", "Timer status valid")
                if (loadingContainer.visibility == android.view.View.VISIBLE) onLoadingTaskComplete()
            } catch (e: JSONException) {
                Log.e("MainActivity", "Timer status parse error", e)
            }
        }
    }

    // Modified fetchVOCControlStateAsync
    private suspend fun fetchVOCControlStateAsync() = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/voc/auto")
        result.onSuccess { response ->
            val state = response.trim()
            if (state == "on" || state == "off") {
                if (!switchVocAuto.isPressed) {
                    switchVocAuto.isChecked = state == "on"
                }
                Log.d("MainActivity", "VOC control valid: $state")
                if (loadingContainer.visibility == android.view.View.VISIBLE) onLoadingTaskComplete()
            } else {
                Log.e("MainActivity", "Invalid VOC state: $state")
            }
        }
    }

    // Modified fetchClockRelayStateAsync
    private suspend fun fetchClockRelayStateAsync() = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/clock/relay/status")
        result.onSuccess { response ->
            val state = response.trim()
            if (state == "ON" || state == "OFF") {
                if (!switchClockRelay.isPressed) {
                    switchClockRelay.isChecked = state == "ON"
                }
                Log.d("MainActivity", "Clock relay valid: $state")
                if (loadingContainer.visibility == android.view.View.VISIBLE) onLoadingTaskComplete()
            } else {
                Log.e("MainActivity", "Invalid relay state: $state")
            }
        }
    }

    // Modified fetchClockBrightnessStateAsync
    private suspend fun fetchClockBrightnessStateAsync() = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/clock/brightness")
        result.onSuccess { response ->
            try {
                val json = JSONObject(response)
                val brightness = json.getInt("brightness")
                val auto = json.getBoolean("auto")

                if (!switchClockAutoBrightness.isPressed) {
                    seekbarClockBrightness.progress = brightness
                    tvClockBrightnessValue.text = brightness.toString()
                    switchClockAutoBrightness.isChecked = auto
                    seekbarClockBrightness.isEnabled = !auto
                }
                Log.d("MainActivity", "Clock brightness valid")
                if (loadingContainer.visibility == android.view.View.VISIBLE) onLoadingTaskComplete()
            } catch (e: JSONException) {
                Log.e("MainActivity", "Clock brightness parse error", e)
            }
        }
    }

    // Super fast device control methods
    private suspend fun toggleDeviceAsync(device: String): Boolean {
        val endpoint = when (device) {
            "fan" -> "/fan/toggle"
            "bigLight" -> "/output/1/toggle"
            "light" -> "/output/2/toggle"
            else -> return false
        }

        return try {
            val result = makeGetRequestAsync(endpoint)
            result.isSuccess
        } catch (e: Exception) {
            false
        }
    }

    private suspend fun toggleVOCControlAsync(enabled: Boolean) = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/voc/auto?state=${if (enabled) "on" else "off"}")
        result.onSuccess {
            Toast.makeText(
                this@MainActivity,
                "VOC control ${if (enabled) "enabled" else "disabled"}",
                Toast.LENGTH_SHORT
            ).show()
        }.onFailure { error ->
            showError("Failed to toggle VOC control: ${error.message}")
            fetchVOCControlStateAsync()
        }
    }

    private suspend fun toggleClockRelayAsync(enabled: Boolean) = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/clock/relay?state=${if (enabled) "on" else "off"}")
        result.onSuccess {
            Toast.makeText(
                this@MainActivity,
                "Clock relay ${if (enabled) "on" else "off"}",
                Toast.LENGTH_SHORT
            ).show()
        }.onFailure { error ->
            showError("Failed to toggle clock relay: ${error.message}")
            fetchClockRelayStateAsync()
        }
    }

    private suspend fun toggleAutoBrightnessAsync(enabled: Boolean) = withContext(Dispatchers.Main) {
        val result = makeGetRequestAsync("/brightness/auto?state=${if (enabled) "true" else "false"}")
        result.onSuccess {
            seekbarBrightness.isEnabled = !enabled
            if (enabled) {
                delay(100)
                fetchSensorDataAsync()
            }
        }.onFailure { error ->
            showError("Failed to toggle auto brightness: ${error.message}")
            fetchSensorDataAsync()
        }
    }

    private suspend fun toggleClockAutoBrightnessAsync(enabled: Boolean) = withContext(Dispatchers.Main) {
        val result = makePostRequestAsync("/clock/brightness/auto", "state=${if (enabled) "on" else "off"}")
        result.onSuccess {
            seekbarClockBrightness.isEnabled = !enabled
        }.onFailure { error ->
            showError("Failed to toggle clock auto brightness: ${error.message}")
            fetchClockBrightnessStateAsync()
        }
    }

    private suspend fun setBrightnessAsync(value: Int) {
        val result = makeGetRequestAsync("/brightness?value=$value")
        result.onFailure { error ->
            showError("Failed to set brightness: ${error.message}")
            fetchSensorDataAsync()
        }
    }

    private suspend fun setClockBrightnessAsync(value: Int) {
        val result = makePostRequestAsync("/clock/brightness", "value=$value")
        result.onFailure { error ->
            showError("Failed to set clock brightness: ${error.message}")
            fetchClockBrightnessStateAsync()
        }
    }

    // Fast timer methods
    private suspend fun startTimerAsync() = withContext(Dispatchers.Main) {
        val device = spinnerTimerDevice.selectedItem.toString()
        val state = spinnerTimerState.selectedItem.toString()
        val durationStr = etTimerDuration.text.toString()

        if (durationStr.isEmpty()) {
            Toast.makeText(this@MainActivity, "Please enter a valid duration", Toast.LENGTH_SHORT).show()
            return@withContext
        }

        val duration = try {
            durationStr.toInt()
        } catch (e: NumberFormatException) {
            Toast.makeText(this@MainActivity, "Please enter a valid number", Toast.LENGTH_SHORT).show()
            return@withContext
        }

        if (duration < 1) {
            Toast.makeText(this@MainActivity, "Duration must be at least 1 minute", Toast.LENGTH_SHORT).show()
            return@withContext
        }

        val deviceParam = when (device.lowercase().replace(" ", "")) {
            "biglight" -> "bigLight"
            else -> device.lowercase().replace(" ", "")
        }

        val postData = "device=$deviceParam&state=$state&duration=$duration"

        val result = makePostRequestAsync("/timer", postData)
        result.onSuccess {
            Toast.makeText(this@MainActivity, "Timer started for $device", Toast.LENGTH_SHORT).show()
            etTimerDuration.setText("")
            delay(100)
            fetchTimerStatusAsync()
        }.onFailure { error ->
            showError("Failed to start timer: ${error.message}")
        }
    }

    private suspend fun cancelAllTimersAsync() = withContext(Dispatchers.Main) {
        val result = makePostRequestAsync("/timer/cancel", "")
        result.onSuccess {
            Toast.makeText(this@MainActivity, "All timers cancelled", Toast.LENGTH_SHORT).show()
            delay(100)
            fetchTimerStatusAsync()
        }.onFailure { error ->
            showError("Failed to cancel timers: ${error.message}")
        }
    }

    private fun restartDevice() {
        AlertDialog.Builder(this)
            .setTitle("Restart Device")
            .setMessage("Are you sure you want to restart JARVIS?")
            .setPositiveButton("Yes") { _, _ ->
                fastUpdateScope.launch {
                    val result = makeGetRequestAsync("/reset")
                    result.onSuccess {
                        Toast.makeText(
                            this@MainActivity,
                            "Device restart initiated. Reconnecting in 8 seconds...",
                            Toast.LENGTH_LONG
                        ).show()

                        stopAllJobs()
                        delay(8000)
                        showLoadingScreen()
                        loadInitialDataAsync()
                    }.onFailure { error ->
                        showError("Failed to restart device: ${error.message}")
                    }
                }
            }
            .setNegativeButton("No", null)
            .show()
    }

    private fun showError(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }
}
